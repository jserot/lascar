<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ListExt (lascar.Utils.ListExt)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">lascar</a> &#x00BB; <a href="../index.html">Utils</a> &#x00BB; ListExt</nav><h1>Module <code>Utils.ListExt</code></h1></header><aside><p>Extension to the <span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List&quot;"><code>Stdlib</code>.List</span> module</p></aside><dl><dt class="spec value" id="val-fold_lefti"><a href="#val-fold_lefti" class="anchor"></a><code><span class="keyword">val</span> fold_lefti : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_lefti f a [b1; ...; bn]</code> is <code>f (... (f 1 (f 0 a b1) b2) ...) bn</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_righti"><a href="#val-fold_righti" class="anchor"></a><code><span class="keyword">val</span> fold_righti : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold_righti f [a1; ...; an] b</code> is <code>f a1 (f (n-2) a2 (... (f (n-1) an b) ...))</code>.</p></dd></dl><dl><dt class="spec value" id="val-split3"><a href="#val-split3" class="anchor"></a><code><span class="keyword">val</span> split3 : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span></code></dt><dd><p>Transform a list of triplets into a triplet of lists.</p></dd></dl><dl><dt class="spec value" id="val-combine3"><a href="#val-combine3" class="anchor"></a><code><span class="keyword">val</span> combine3 : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> list</span></code></dt><dd><p>Transform a triplet of lists into a list of triplets.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string f sep [x1;...;xn]</code> returns <code>f x1 ^ sep ^ f x2 ^ sep ^ ... ^ sep ^ f xn</code> or the empty string if the list is empty</p></dd></dl><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val</span> range : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>make f n1 n2</code> returns <code>[f n1; ..., f n2]</code> if <code>n2&gt;=n1</code> or the empty list if <code>n2&lt;n1</code></p></dd></dl><dl><dt class="spec value" id="val-index_of"><a href="#val-index_of" class="anchor"></a><code><span class="keyword">val</span> index_of : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>index_of e l</code> returns the index of the first occurence of <code>e</code> in list <code>l</code>, starting at 0.</p><dl><dt>raises Failure</dt><dd><p>is <code>e</code> does not occur in <code>l</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-flat_map"><a href="#val-flat_map" class="anchor"></a><code><span class="keyword">val</span> flat_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>flat_map f [x1;...,xn]</code> is <code>f x1 @ f x2 @ ... @ f xn</code></p></dd></dl><dl><dt class="spec value" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span class="keyword">val</span> inter : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>inter l1 l2</code> returns the intersection of the lists <code>l1</code> and <code>l2</code></p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>union l1 l2</code> returns the union of the lists <code>l1</code> and <code>l2</code></p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <span>?&#8288;cmp:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>merge p l1 l2</code> merges lists <code>l1</code> and <code>l2</code> using comparison function <code>cmp</code> (default: Pervasives.compare). For example, <code>merge [1;3;8] [2;5;6;10] = [1;2;3;5;5;8;10]</code>.</p></dd></dl><dl><dt class="spec value" id="val-prod"><a href="#val-prod" class="anchor"></a><code><span class="keyword">val</span> prod : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span></code></dt><dd><p><code>prod f l1 l2</code> computes the &quot;product&quot; of lists <code>l1</code> and <code>l2</code>, i.e. the list obtained by applying <code>f</code> to each possible pair of elements of <code>l1</code> and <code>l2</code>.</p></dd></dl><dl><dt class="spec value" id="val-cart_prod2"><a href="#val-cart_prod2" class="anchor"></a><code><span class="keyword">val</span> cart_prod2 : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dd><p><code>cart_prod</code> is a specialized version of <code>prod</code> in which <code>f x y = (x,y)</code></p></dd></dl><dl><dt class="spec value" id="val-prod3"><a href="#val-prod3" class="anchor"></a><code><span class="keyword">val</span> prod3 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> list</span></code></dt><dt class="spec value" id="val-cart_prod3"><a href="#val-cart_prod3" class="anchor"></a><code><span class="keyword">val</span> cart_prod3 : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> list</span></code></dt><dd><p><code>prod3</code> (resp. <code>cart_prod3</code>) are generalisations of <a href="index.html#val-prod"><code>prod</code></a> (resp. <a href="index.html#val-cart_prod2"><code>cart_prod2</code></a>) to three input lists</p></dd></dl><dl><dt class="spec value" id="val-cart_prodn"><a href="#val-cart_prodn" class="anchor"></a><code><span class="keyword">val</span> cart_prodn : <span><span><span class="type-var">'a</span> list</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span></code></dt><dd><p><code>gen_cart_prod</code> computes the n-ary cartesian product of lists.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>filter_map p f l</code> is a short-cut for <code>List.map f (List.filter p l)</code></p></dd></dl><dl><dt class="spec value" id="val-iter_sep"><a href="#val-iter_sep" class="anchor"></a><code><span class="keyword">val</span> iter_sep : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter_sep f g l</code> is like <code>List.iter f l</code> but calls function <code>g</code> between each call to function <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter_fst"><a href="#val-iter_fst" class="anchor"></a><code><span class="keyword">val</span> iter_fst : <span>(bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter_fst f [x1;x2;...xn]</code> is <code>f true x1; f false x2; ...; f false xn</code></p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>remove e l</code> is a short-cut for <code>List.filter (fun e' -&gt; e &lt;&gt; e') l)</code></p></dd></dl><dl><dt class="spec value" id="val-power_set"><a href="#val-power_set" class="anchor"></a><code><span class="keyword">val</span> power_set : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span></code></dt><dd><p><code>power_set l</code> computes the &quot;power set&quot; of <code>l</code>, i.e. the list of all lists composed of elements of <code>l</code>. The length of the result is <code>2^n</code>, where <code>n</code> is the length of <code>l</code>. Example: <code>power [1;2;3]</code> is <code>[[];[1];[2];[3];[1;2];[1;3];[2;3];[1;2;3]]</code></p></dd></dl><dl><dt class="spec value" id="val-power"><a href="#val-power" class="anchor"></a><code><span class="keyword">val</span> power : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span></code></dt><dd><p><code>power n l</code> computes the list of all lists of length <code>n</code> made of elements of <code>l</code>. The length of the result is <code>m^n</code>, where <code>m</code> is the length of <code>l</code>. Example : <code>power 2 [1;2;3]</code> is <code>[[1;1];[2;1];[3;1];[1;2];[2;2];[3;2];[1;3];[2;3];[3;3]]</code></p></dd></dl><dl><dt class="spec value" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span class="keyword">val</span> assoc : <span>?&#8288;cmp:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'c</span>)</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dt class="spec value" id="val-mem_assoc"><a href="#val-mem_assoc" class="anchor"></a><code><span class="keyword">val</span> mem_assoc : <span>?&#8288;cmp:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'c</span>)</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>assoc</code> (resp. <code>mem_assoc</code>) is a variant of <span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List.assoc&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List&quot;"><code>Stdlib</code>.List</span>.assoc</span> (resp. <span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List.mem_assoc&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Stdlib.List&quot;"><code>Stdlib</code>.List</span>.mem_assoc</span>) in which the comparison function used for comparing keys can be passed as an optional argument. By default, <span class="xref-unresolved" title="unresolved reference to &quot;Pervasive.compare&quot;"><code>Pervasive</code>.compare</span> is used.</p></dd></dl><dl><dt class="spec value" id="val-update_assoc"><a href="#val-update_assoc" class="anchor"></a><code><span class="keyword">val</span> update_assoc : <span>?&#8288;cmp:<span>(<span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'v</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span></code></dt><dd><p><code>update_assoc f k v l</code> replaces the value <code>v'</code> associated to each occurrence of key <code>k</code> in the association list <code>l</code> by <code>f v' v</code>. If <code>k</code> does not occur, <code>l</code> is unchanged. As for <a href="index.html#val-assoc"><code>assoc</code></a> and <a href="index.html#val-mem_assoc"><code>mem_assoc</code></a>, the comparison function can be specified with the optional argument <code>cmp</code>.</p></dd></dl><dl><dt class="spec value" id="val-replace_assoc"><a href="#val-replace_assoc" class="anchor"></a><code><span class="keyword">val</span> replace_assoc : <span>?&#8288;cmp:<span>(<span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span></code></dt><dd><p><code>replace_assoc k v l</code> is <code>update_assoc (fun _ v -&gt; v) v k</code>. It replaces the value associated to each occurrence of key <code>k</code> by <code>v</code> in the association list <code>l</code>. If <code>k</code> does not occur, <code>l</code> is unchanged. As for <a href="index.html#val-assoc"><code>assoc</code></a> and <a href="index.html#val-mem_assoc"><code>mem_assoc</code></a>, the comparison function can be specified with the optional argument <code>cmp</code>.</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : <span>?&#8288;cmp:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span>)</span> list</span></code></dt><dd><p><code>partition [(x1,y1);...;(xn;yn)]</code> returns the list <code>[k1,ys1; ...;km,ysm]</code> where <code>k1</code>,...,<code>km</code> are all the distinct values occuring in <code>[x1;...;xn]</code> and <code>ysi</code> the list of values <code>yj</code> paired with <code>ki</code> in the input list. For example <code>partition [(1,&quot;a&quot;);(3,&quot;b&quot;);(1,&quot;c&quot;);(3,&quot;d&quot;)]</code> is <code>[3,[&quot;d&quot;;&quot;b&quot;];1,[&quot;b&quot;;&quot;a&quot;]]</code>.</p></dd></dl><dl><dt class="spec value" id="val-scatter"><a href="#val-scatter" class="anchor"></a><code><span class="keyword">val</span> scatter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> array</span></code></dt><dd><p><code>scatter h l</code> returns an array <code>a</code> in which <code>a.(i)</code> is the list of all elements <code>x</code> of <code>l</code> such that <code>h x = i</code>. The length of the array is computed from the maximum value of <code>h</code> on <code>l</code>. Example: <code>scatter String.length [&quot;a&quot;;&quot;bc&quot;;&quot;de&quot;;&quot;fghi&quot;]</code> is <code>[|[];[&quot;a&quot;];[&quot;bc;de&quot;];[];[&quot;fghi&quot;]|]</code>. As for <a href="index.html#val-assoc"><code>assoc</code></a> and <a href="index.html#val-mem_assoc"><code>mem_assoc</code></a>, the comparison function can be specified with the optional argument <code>cmp</code>.</p></dd></dl><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : string <span>&#45;&gt;</span> <span>(<span>Stdlib.Genlex.token Stdlib.Stream.t</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>Stdlib.Genlex.token Stdlib.Stream.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Higher-order parser for lists</p></dd></dl></div></body></html>