<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ListExt (lascar.Utils.ListExt)</title><link rel="stylesheet" href="../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">lascar</a> &#x00BB; <a href="../index.html">Utils</a> &#x00BB; ListExt</nav><header class="odoc-preamble"><h1>Module <code><span>Utils.ListExt</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#extension-to-the-stdlib.list-module">Extension to the <code>Stdlib.List</code> module</a></li></ul></nav><div class="odoc-content"><h3 id="extension-to-the-stdlib.list-module"><a href="#extension-to-the-stdlib.list-module" class="anchor"></a>Extension to the <code>Stdlib.List</code> module</h3><div class="odoc-spec"><div class="spec value anchored" id="val-fold_lefti"><a href="#val-fold_lefti" class="anchor"></a><code><span><span class="keyword">val</span> fold_lefti : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_lefti f a [b1; ...; bn]</code> is <code>f (... (f 1 (f 0 a b1) b2) ...) bn</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_righti"><a href="#val-fold_righti" class="anchor"></a><code><span><span class="keyword">val</span> fold_righti : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>fold_righti f [a1; ...; an] b</code> is <code>f a1 (f (n-2) a2 (... (f (n-1) an b) ...))</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split3"><a href="#val-split3" class="anchor"></a><code><span><span class="keyword">val</span> split3 : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p>Transform a list of triplets into a triplet of lists.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-combine3"><a href="#val-combine3" class="anchor"></a><code><span><span class="keyword">val</span> combine3 : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> list</span></span></code></div><div class="spec-doc"><p>Transform a triplet of lists into a list of triplets.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string f sep [x1;...;xn]</code> returns <code>f x1 ^ sep ^ f x2 ^ sep ^ ... ^ sep ^ f xn</code> or the empty string if the list is empty</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-range"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>make f n1 n2</code> returns <code>[f n1; ..., f n2]</code> if <code>n2&gt;=n1</code> or the empty list if <code>n2&lt;n1</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-index_of"><a href="#val-index_of" class="anchor"></a><code><span><span class="keyword">val</span> index_of : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>index_of e l</code> returns the index of the first occurence of <code>e</code> in list <code>l</code>, starting at 0.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>is <code>e</code> does not occur in <code>l</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flat_map"><a href="#val-flat_map" class="anchor"></a><code><span><span class="keyword">val</span> flat_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>flat_map f [x1;...,xn]</code> is <code>f x1 @ f x2 @ ... @ f xn</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span><span class="keyword">val</span> inter : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>inter l1 l2</code> returns the intersection of the lists <code>l1</code> and <code>l2</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>union l1 l2</code> returns the union of the lists <code>l1</code> and <code>l2</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span>?cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>merge p l1 l2</code> merges lists <code>l1</code> and <code>l2</code> using comparison function <code>cmp</code> (default: Pervasives.compare). For example, <code>merge [1;3;8] [2;5;6;10] = [1;2;3;5;5;8;10]</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prod"><a href="#val-prod" class="anchor"></a><code><span><span class="keyword">val</span> prod : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>prod f l1 l2</code> computes the &quot;product&quot; of lists <code>l1</code> and <code>l2</code>, i.e. the list obtained by applying <code>f</code> to each possible pair of elements of <code>l1</code> and <code>l2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cart_prod2"><a href="#val-cart_prod2" class="anchor"></a><code><span><span class="keyword">val</span> cart_prod2 : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>cart_prod</code> is a specialized version of <code>prod</code> in which <code>f x y = (x,y)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prod3"><a href="#val-prod3" class="anchor"></a><code><span><span class="keyword">val</span> prod3 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cart_prod3"><a href="#val-cart_prod3" class="anchor"></a><code><span><span class="keyword">val</span> cart_prod3 : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>prod3</code> (resp. <code>cart_prod3</code>) are generalisations of <a href="#val-prod"><code>prod</code></a> (resp. <a href="#val-cart_prod2"><code>cart_prod2</code></a>) to three input lists</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cart_prodn"><a href="#val-cart_prodn" class="anchor"></a><code><span><span class="keyword">val</span> cart_prodn : <span><span><span><span class="type-var">'a</span> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p><code>gen_cart_prod</code> computes the n-ary cartesian product of lists.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>filter_map p f l</code> is a short-cut for <code>List.map f (List.filter p l)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_sep"><a href="#val-iter_sep" class="anchor"></a><code><span><span class="keyword">val</span> iter_sep : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter_sep f g l</code> is like <code>List.iter f l</code> but calls function <code>g</code> between each call to function <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_fst"><a href="#val-iter_fst" class="anchor"></a><code><span><span class="keyword">val</span> iter_fst : <span><span>(<span>bool <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter_fst f [x1;x2;...xn]</code> is <code>f true x1; f false x2; ...; f false xn</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>remove e l</code> is a short-cut for <code>List.filter (fun e' -&gt; e &lt;&gt; e') l)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-power_set"><a href="#val-power_set" class="anchor"></a><code><span><span class="keyword">val</span> power_set : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p><code>power_set l</code> computes the &quot;power set&quot; of <code>l</code>, i.e. the list of all lists composed of elements of <code>l</code>. The length of the result is <code>2^n</code>, where <code>n</code> is the length of <code>l</code>. Example: <code>power [1;2;3]</code> is <code>[[];[1];[2];[3];[1;2];[1;3];[2;3];[1;2;3]]</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-power"><a href="#val-power" class="anchor"></a><code><span><span class="keyword">val</span> power : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p><code>power n l</code> computes the list of all lists of length <code>n</code> made of elements of <code>l</code>. The length of the result is <code>m^n</code>, where <code>m</code> is the length of <code>l</code>. Example : <code>power 2 [1;2;3]</code> is <code>[[1;1];[2;1];[3;1];[1;2];[2;2];[3;2];[1;3];[2;3];[3;3]]</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span><span class="keyword">val</span> assoc : <span>?cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'c</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem_assoc"><a href="#val-mem_assoc" class="anchor"></a><code><span><span class="keyword">val</span> mem_assoc : <span>?cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'c</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>assoc</code> (resp. <code>mem_assoc</code>) is a variant of <code>Stdlib</code>.List.assoc (resp. <code>Stdlib</code>.List.mem_assoc) in which the comparison function used for comparing keys can be passed as an optional argument. By default, <code>Pervasive</code>.compare is used.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_assoc"><a href="#val-update_assoc" class="anchor"></a><code><span><span class="keyword">val</span> update_assoc : 
  <span>?cmp:<span>(<span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'v</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>update_assoc f k v l</code> replaces the value <code>v'</code> associated to each occurrence of key <code>k</code> in the association list <code>l</code> by <code>f v' v</code>. If <code>k</code> does not occur, <code>l</code> is unchanged. As for <a href="#val-assoc"><code>assoc</code></a> and <a href="#val-mem_assoc"><code>mem_assoc</code></a>, the comparison function can be specified with the optional argument <code>cmp</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-replace_assoc"><a href="#val-replace_assoc" class="anchor"></a><code><span><span class="keyword">val</span> replace_assoc : 
  <span>?cmp:<span>(<span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'k</span> * <span class="type-var">'v</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>replace_assoc k v l</code> is <code>update_assoc (fun _ v -&gt; v) v k</code>. It replaces the value associated to each occurrence of key <code>k</code> by <code>v</code> in the association list <code>l</code>. If <code>k</code> does not occur, <code>l</code> is unchanged. As for <a href="#val-assoc"><code>assoc</code></a> and <a href="#val-mem_assoc"><code>mem_assoc</code></a>, the comparison function can be specified with the optional argument <code>cmp</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span><span class="keyword">val</span> partition : <span>?cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>partition [(x1,y1);...;(xn;yn)]</code> returns the list <code>[k1,ys1; ...;km,ysm]</code> where <code>k1</code>,...,<code>km</code> are all the distinct values occuring in <code>[x1;...;xn]</code> and <code>ysi</code> the list of values <code>yj</code> paired with <code>ki</code> in the input list. For example <code>partition [(1,&quot;a&quot;);(3,&quot;b&quot;);(1,&quot;c&quot;);(3,&quot;d&quot;)]</code> is <code>[3,[&quot;d&quot;;&quot;b&quot;];1,[&quot;b&quot;;&quot;a&quot;]]</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-scatter"><a href="#val-scatter" class="anchor"></a><code><span><span class="keyword">val</span> scatter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> array</span></span></code></div><div class="spec-doc"><p><code>scatter h l</code> returns an array <code>a</code> in which <code>a.(i)</code> is the list of all elements <code>x</code> of <code>l</code> such that <code>h x = i</code>. The length of the array is computed from the maximum value of <code>h</code> on <code>l</code>. Example: <code>scatter String.length [&quot;a&quot;;&quot;bc&quot;;&quot;de&quot;;&quot;fghi&quot;]</code> is <code>[|[];[&quot;a&quot;];[&quot;bc;de&quot;];[];[&quot;fghi&quot;]|]</code>. As for <a href="#val-assoc"><code>assoc</code></a> and <a href="#val-mem_assoc"><code>mem_assoc</code></a>, the comparison function can be specified with the optional argument <code>cmp</code>.</p></div></div></div></body></html>